## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *
from eudplib.core.eudfunc import EUDTraceLog, EUDTracedFunc, EUDTracedTypedFunc, EUDTracedMethod, EUDTracedTypedMethod
from eudplib.epscript.helper import _RELIMP, _IGVA, _CGFW, _ARR, _VARR, _SRET, _SV, _ATTW, _ARRW, _ATTC, _ARRC, _L2V, _LVAR, _LSH
# (Line 1) object Node {
# (Line 2) var kills;
class Node(EUDStruct):
    # (Line 3) var epd;
    # (Line 5) function constructor(kills, epd) {
    @EUDMethod
    def constructor(this, kills, epd):
        # (Line 6) this.kills = kills;
        _ATTW(this, 'kills') << (kills)
        # (Line 7) this.epd = epd;
        _ATTW(this, 'epd') << (epd)
        # (Line 8) }
        # (Line 9) };

    # (Line 11) object MaxHeap {
    _fields_ = [
        'kills',
        'epd',
    ]

# (Line 12) var heap : EUDArray;
class MaxHeap(EUDStruct):
    # (Line 13) var size; // array 크기
    # (Line 14) var last; // 마지막 위치
    # (Line 16) function constructor(array:EUDArray, size, last) {
    @EUDTypedMethod([EUDArray, None, None])
    def constructor(this, array, size, last):
        # (Line 17) this.heap = array;
        _ATTW(this, 'heap') << (array)
        # (Line 18) this.size = size;
        _ATTW(this, 'size') << (size)
        # (Line 19) this.last = last;
        _ATTW(this, 'last') << (last)
        # (Line 21) if(this.last != 0) {
        if EUDIf()(_ATTC(this, 'last') == 0, neg=True):
            # (Line 22) this.heapify();
            this.heapify()
            # (Line 23) }
            # (Line 24) }
        EUDEndIf()
        # (Line 26) function priority(val1, val2) {

    @EUDMethod
    def priority(this, val1, val2):
        # (Line 27) if(val1 < val2) return true;
        if EUDIf()(val1 >= val2, neg=True):
            EUDReturn(True)
            # (Line 28) return false;
        EUDEndIf()
        EUDReturn(False)
        # (Line 29) }
        # (Line 31) function heapify() {

    @EUDMethod
    def heapify(this):
        # (Line 32) for (var i=this.size-1; i>0; i--) {
        i = _LVAR([this.size - 1])
        if EUDWhile()(i <= 0, neg=True):
            def _t2():
                i.__isub__(1)
            # (Line 33) var node = i;
            node = _LVAR([i])
            # (Line 34) while (node < this.size) {
            if EUDWhile()(node >= this.size, neg=True):
                # (Line 35) var child = node*2;
                child = _LVAR([node * 2])
                # (Line 36) var sibling = child+1;
                sibling = _LVAR([child + 1])
                # (Line 38) if (child >= this.size) break;
                if EUDIf()(child >= this.size):
                    EUDBreak()
                    # (Line 39) if (sibling < this.size && this.priority(this.heap[child-1], this.heap[sibling-1])) {
                EUDEndIf()
                if EUDIf()(EUDSCAnd()(sibling >= this.size, neg=True)(this.priority(this.heap[child - 1], this.heap[sibling - 1]))()):
                    # (Line 40) child = sibling;
                    child << (sibling)
                    # (Line 41) }
                    # (Line 42) if (this.priority(this.heap[node-1], this.heap[child-1])) {
                EUDEndIf()
                if EUDIf()(this.priority(this.heap[node - 1], this.heap[child - 1])):
                    # (Line 43) var temp = this.heap[node-1];
                    temp = _LVAR([this.heap[node - 1]])
                    # (Line 44) this.heap[node-1] = this.heap[child-1];
                    _ARRW(this.heap, node - 1) << (this.heap[child - 1])
                    # (Line 45) this.heap[child-1] = temp;
                    _ARRW(this.heap, child - 1) << (temp)
                    # (Line 46) node = child;
                    node << (child)
                    # (Line 47) }
                    # (Line 48) else break;
                if EUDElse()():
                    EUDBreak()
                    # (Line 49) }
                EUDEndIf()
                # (Line 50) }
            EUDEndWhile()
            # (Line 51) }
            EUDSetContinuePoint()
            _t2()
        EUDEndWhile()
        # (Line 53) function heappush(val) {

    @EUDMethod
    def heappush(this, val):
        # (Line 55) if (this.last == this.size) return -1;
        if EUDIf()(_ATTC(this, 'last') == this.size):
            EUDReturn(-1)
            # (Line 56) var node = this.last+1;
        EUDEndIf()
        node = _LVAR([this.last + 1])
        # (Line 57) this.last++;
        _ATTW(this, 'last').__iadd__(1)
        # (Line 60) while (node != 1 && this.priority(this.heap[(node/2)-1], val)) {
        if EUDWhile()(EUDSCAnd()(node == 1, neg=True)(this.priority(this.heap[(node // 2) - 1], val))()):
            # (Line 61) this.heap[node-1] = this.heap[(node/2)-1];
            _ARRW(this.heap, node - 1) << (this.heap[(node // 2) - 1])
            # (Line 62) node /= 2;
            node.__ifloordiv__(2)
            # (Line 63) }
            # (Line 64) this.heap[node-1] = val;
        EUDEndWhile()
        _ARRW(this.heap, node - 1) << (val)
        # (Line 65) return this.last;
        EUDReturn(this.last)
        # (Line 66) }
        # (Line 68) function heappop() {

    @EUDMethod
    def heappop(this):
        # (Line 70) if(this.last == 0) return -1;
        if EUDIf()(_ATTC(this, 'last') == 0):
            EUDReturn(-1)
            # (Line 71) this.last--;
        EUDEndIf()
        _ATTW(this, 'last').__isub__(1)
        # (Line 72) const pop = this.heap[0];
        pop = this.heap[0]
        # (Line 73) var temp = this.heap[this.last];
        temp = _LVAR([this.heap[this.last]])
        # (Line 74) this.heap[this.last] = 0;
        _ARRW(this.heap, this.last) << (0)
        # (Line 76) if (this.last > 0) {
        if EUDIf()(_ATTC(this, 'last') <= 0, neg=True):
            # (Line 77) var parent = 1;
            parent = _LVAR([1])
            # (Line 78) var child = 2;
            child = _LVAR([2])
            # (Line 80) while (child <= this.last+1) {
            if EUDWhile()(child <= this.last + 1):
                # (Line 81) if(child < this.last+1 && this.priority(this.heap[child-1], this.heap[child])) {
                if EUDIf()(EUDSCAnd()(child >= this.last + 1, neg=True)(this.priority(this.heap[child - 1], this.heap[child]))()):
                    # (Line 82) child++;
                    child.__iadd__(1)
                    # (Line 83) }
                    # (Line 84) if(!this.priority(temp, this.heap[child-1])) {
                EUDEndIf()
                if EUDIf()(this.priority(temp, this.heap[child - 1]), neg=True):
                    # (Line 85) break;
                    EUDBreak()
                    # (Line 86) }
                    # (Line 88) this.heap[parent-1] = this.heap[child-1];
                EUDEndIf()
                _ARRW(this.heap, parent - 1) << (this.heap[child - 1])
                # (Line 89) parent = child;
                parent << (child)
                # (Line 90) child *= 2;
                child.__imul__(2)
                # (Line 91) }
                # (Line 93) this.heap[parent-1] = temp;
            EUDEndWhile()
            _ARRW(this.heap, parent - 1) << (temp)
            # (Line 94) }
            # (Line 95) return pop;
        EUDEndIf()
        EUDReturn(pop)
        # (Line 96) }
        # (Line 98) function print() {

    @EUDMethod
    def print(this):
        # (Line 99) const s = StringBuffer(1024);
        s = StringBuffer(1024)
        # (Line 100) s.insert(0, "\x04Heap : ");
        s.insert(0, "\x04Heap : ")
        # (Line 101) for (var i=0; i<this.size; i++) {
        i = _LVAR([0])
        if EUDWhile()(i >= this.size, neg=True):
            def _t2():
                i.__iadd__(1)
            # (Line 102) s.appendf("{}, ", this.heap[i]);
            s.appendf("{}, ", this.heap[i])
            # (Line 103) }
            # (Line 104) s.Display();
            EUDSetContinuePoint()
            _t2()
        EUDEndWhile()
        s.Display()
        # (Line 105) }
        # (Line 106) };

    # (Line 108) object NodeHeap extends MaxHeap {
    _fields_ = [
        ('heap', EUDArray),
        'size',
        'last',
    ]

# (Line 109) function constructor(array:EUDArray, size, last) {
class NodeHeap(MaxHeap):
    @EUDTypedMethod([EUDArray, None, None])
    def constructor(this, array, size, last):
        # (Line 110) MaxHeap.constructor(this, array, size, last);
        MaxHeap.constructor(this, array, size, last)
        # (Line 111) }
        # (Line 113) function priority(val1:Node, val2:Node) {

    @EUDTypedMethod([Node, Node])
    def priority(this, val1, val2):
        # (Line 114) if(val1 == 0 || val2 == 0) return false;
        if EUDIf()(EUDSCOr()(val1 == 0)(val2 == 0)()):
            EUDReturn(False)
            # (Line 115) if(val1.kills < val2.kills) return true;
        EUDEndIf()
        if EUDIf()(_ATTC(val1, 'kills') >= val2.kills, neg=True):
            EUDReturn(True)
            # (Line 116) return false;
        EUDEndIf()
        EUDReturn(False)
        # (Line 117) }
        # (Line 119) function print() {

    @EUDMethod
    def print(this):
        # (Line 120) const s = StringBuffer(1024);
        s = StringBuffer(1024)
        # (Line 121) s.insert(0, "\x04Heap : ");
        s.insert(0, "\x04Heap : ")
        # (Line 122) for (var i=0; i<this.size; i++) {
        i = _LVAR([0])
        if EUDWhile()(i >= this.size, neg=True):
            def _t2():
                i.__iadd__(1)
            # (Line 123) if (this.heap[i] == 0) {
            if EUDIf()(_ARRC(this.heap, i) == 0):
                # (Line 124) s.appendf("0, ");
                s.appendf("0, ")
                # (Line 125) }
                # (Line 126) else {
            if EUDElse()():
                # (Line 127) const node = Node.cast(this.heap[i]);
                node = Node.cast(this.heap[i])
                # (Line 128) s.appendf("{}:{}, ", node.kills, node.epd);
                s.appendf("{}:{}, ", node.kills, node.epd)
                # (Line 129) }
                # (Line 130) }
            EUDEndIf()
            # (Line 131) s.Display();
            EUDSetContinuePoint()
            _t2()
        EUDEndWhile()
        s.Display()
        # (Line 132) }
        # (Line 133) };

    # (Line 135) object ArrayHeap extends MaxHeap {
    _fields_ = [
    ]

# (Line 136) var length;
class ArrayHeap(MaxHeap):
    # (Line 138) function constructor(array:EUDArray, size, last, length) {
    @EUDTypedMethod([EUDArray, None, None, None])
    def constructor(this, array, size, last, length):
        # (Line 139) MaxHeap.constructor(this, array, size, last);
        MaxHeap.constructor(this, array, size, last)
        # (Line 140) this.length = length; // 각 원소(배열)의 크기를 저장함.
        _ATTW(this, 'length') << (length)
        # (Line 141) }
        # (Line 143) function priority(val1:EUDArray, val2:EUDArray) {

    @EUDTypedMethod([EUDArray, EUDArray])
    def priority(this, val1, val2):
        # (Line 145) if(val1 == 0 || val2 == 0) return false;
        if EUDIf()(EUDSCOr()(val1 == 0)(val2 == 0)()):
            EUDReturn(False)
            # (Line 146) for (var i=0; i<this.length; i++) {
        EUDEndIf()
        i = _LVAR([0])
        if EUDWhile()(i >= this.length, neg=True):
            def _t3():
                i.__iadd__(1)
            # (Line 147) if(val1[i] < val2[i]) return true;
            if EUDIf()(_ARRC(val1, i) >= val2[i], neg=True):
                EUDReturn(True)
                # (Line 148) else if(val1[i] > val2[i]) return false;
            if EUDElseIf()(_ARRC(val1, i) <= val2[i], neg=True):
                EUDReturn(False)
                # (Line 150) }
            EUDEndIf()
            # (Line 151) return false;
            EUDSetContinuePoint()
            _t3()
        EUDEndWhile()
        EUDReturn(False)
        # (Line 152) }
        # (Line 154) function print() {

    @EUDMethod
    def print(this):
        # (Line 155) const s = StringBuffer(1024);
        s = StringBuffer(1024)
        # (Line 156) s.insert(0, "\x04Heap : ");
        s.insert(0, "\x04Heap : ")
        # (Line 157) for (var i=0; i<this.size; i++) {
        i = _LVAR([0])
        if EUDWhile()(i >= this.size, neg=True):
            def _t2():
                i.__iadd__(1)
            # (Line 158) if (this.heap[i] == 0) {
            if EUDIf()(_ARRC(this.heap, i) == 0):
                # (Line 159) s.appendf("0, ");
                s.appendf("0, ")
                # (Line 160) }
                # (Line 161) else {
            if EUDElse()():
                # (Line 162) const node = EUDArray.cast(this.heap[i]);
                node = EUDArray.cast(this.heap[i])
                # (Line 163) s.appendf("(");
                s.appendf("(")
                # (Line 164) for (var i=0; i<this.length; i++) {
                i_1 = _LVAR([0])
                if EUDWhile()(i_1 >= this.length, neg=True):
                    def _t5():
                        i_1.__iadd__(1)
                    # (Line 165) s.appendf("{},", node[i]);
                    s.appendf("{},", node[i_1])
                    # (Line 166) }
                    # (Line 167) s.appendf("), ");
                    EUDSetContinuePoint()
                    _t5()
                EUDEndWhile()
                s.appendf("), ")
                # (Line 168) }
                # (Line 169) }
            EUDEndIf()
            # (Line 170) s.Display();
            EUDSetContinuePoint()
            _t2()
        EUDEndWhile()
        s.Display()
        # (Line 171) }
        # (Line 172) };

    _fields_ = [
        'length',
    ]

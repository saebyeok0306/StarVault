## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *
from eudplib.core.eudfunc import EUDTraceLog, EUDTracedFunc, EUDTracedTypedFunc, EUDTracedMethod, EUDTracedTypedMethod
from eudplib.epscript.helper import _RELIMP, _IGVA, _CGFW, _ARR, _VARR, _SRET, _SV, _ATTW, _ARRW, _ATTC, _ARRC, _L2V, _LVAR, _LSH
# (Line 9) const MAX_SIZE = 100;
MAX_SIZE = _CGFW(lambda: [100], 1)[0]
# (Line 11) object Val {
# (Line 12) var start;
class Val(EUDStruct):
    # (Line 13) var end;
    # (Line 14) var mid;
    # (Line 16) function constructor(start, end, mid) {
    @EUDMethod
    def constructor(this, start, end, mid):
        # (Line 17) this.start = start;
        _ATTW(this, 'start') << (start)
        # (Line 18) this.end = end;
        _ATTW(this, 'end') << (end)
        # (Line 19) this.mid = mid;
        _ATTW(this, 'mid') << (mid)
        # (Line 20) }
        # (Line 21) };

    # (Line 23) object MergeSort {
    _fields_ = [
        'start',
        'end',
        'mid',
    ]

# (Line 24) var array: EUDArray;
class MergeSort(EUDStruct):
    # (Line 25) var sorted: EUDArray;
    # (Line 26) var length;
    # (Line 27) var stack1_ptr;
    # (Line 28) var stack1: EUDArray; // Fixed (divide)
    # (Line 29) var stack2_ptr;
    # (Line 30) var stack2: EUDArray; // Fixed
    # (Line 32) function constructor(input_array:EUDArray, sorted_array:EUDArray, length) {
    @EUDTypedMethod([EUDArray, EUDArray, None])
    def constructor(this, input_array, sorted_array, length):
        # (Line 33) this.array = input_array;
        _ATTW(this, 'array') << (input_array)
        # (Line 34) this.sorted = sorted_array;
        _ATTW(this, 'sorted') << (sorted_array)
        # (Line 35) this.length = length;
        _ATTW(this, 'length') << (length)
        # (Line 36) this.stack1_ptr = 0;
        _ATTW(this, 'stack1_ptr') << (0)
        # (Line 37) this.stack2_ptr = 0;
        _ATTW(this, 'stack2_ptr') << (0)
        # (Line 38) this.stack1 = EUDArray(MAX_SIZE);
        _ATTW(this, 'stack1') << (EUDArray(MAX_SIZE))
        # (Line 39) this.stack2 = EUDArray(MAX_SIZE);
        _ATTW(this, 'stack2') << (EUDArray(MAX_SIZE))
        # (Line 40) this.sort();
        this.sort()
        # (Line 41) }
        # (Line 43) function divide(val:Val){

    @EUDTypedMethod([Val])
    def divide(this, val):
        # (Line 44) if (val.start < val.end) {
        if EUDIf()(_ATTC(val, 'start') >= val.end, neg=True):
            # (Line 45) const mid = (val.start+val.end)/2;
            mid = (val.start + val.end) // 2
            # (Line 46) this.stack1[this.stack1_ptr] = Val.alloc(val.start, val.end, mid);
            _ARRW(this.stack1, this.stack1_ptr) << (Val.alloc(val.start, val.end, mid))
            # (Line 47) this.stack1_ptr++;
            _ATTW(this, 'stack1_ptr').__iadd__(1)
            # (Line 48) this.stack2[this.stack2_ptr] = Val.alloc(val.start, mid, 0);
            _ARRW(this.stack2, this.stack2_ptr) << (Val.alloc(val.start, mid, 0))
            # (Line 49) this.stack2_ptr++;
            _ATTW(this, 'stack2_ptr').__iadd__(1)
            # (Line 50) this.stack2[this.stack2_ptr] = Val.alloc(mid+1, val.end, 0);
            _ARRW(this.stack2, this.stack2_ptr) << (Val.alloc(mid + 1, val.end, 0))
            # (Line 51) this.stack2_ptr++;
            _ATTW(this, 'stack2_ptr').__iadd__(1)
            # (Line 52) }
            # (Line 53) Val.free(val);
        EUDEndIf()
        Val.free(val)
        # (Line 54) }
        # (Line 56) function merge(val:Val) {

    @EUDTypedMethod([Val])
    def merge(this, val):
        # (Line 57) var i = val.start;
        i = _LVAR([val.start])
        # (Line 58) var j = val.mid+1;
        j = _LVAR([val.mid + 1])
        # (Line 59) var k = val.start;
        k = _LVAR([val.start])
        # (Line 61) while (i <= val.mid && j <= val.end) {
        if EUDWhile()(EUDSCAnd()(i <= val.mid)(j <= val.end)()):
            # (Line 62) if(this.array[i] <= this.array[j]) {
            if EUDIf()(_ARRC(this.array, i) <= this.array[j]):
                # (Line 63) this.sorted[k] = this.array[i];
                _ARRW(this.sorted, k) << (this.array[i])
                # (Line 64) i++;
                i.__iadd__(1)
                # (Line 65) }
                # (Line 66) else {
            if EUDElse()():
                # (Line 67) this.sorted[k] = this.array[j];
                _ARRW(this.sorted, k) << (this.array[j])
                # (Line 68) j++;
                j.__iadd__(1)
                # (Line 69) }
                # (Line 70) k++;
            EUDEndIf()
            k.__iadd__(1)
            # (Line 71) }
            # (Line 73) if (i > val.mid) {
        EUDEndWhile()
        if EUDIf()(i <= val.mid, neg=True):
            # (Line 74) for (var t=j; t <= val.end; t++) {
            t = _LVAR([j])
            if EUDWhile()(t <= val.end):
                def _t5():
                    t.__iadd__(1)
                # (Line 75) this.sorted[k] = this.array[t];
                _ARRW(this.sorted, k) << (this.array[t])
                # (Line 76) k++;
                k.__iadd__(1)
                # (Line 77) }
                # (Line 78) } else {
                EUDSetContinuePoint()
                _t5()
            EUDEndWhile()
        if EUDElse()():
            # (Line 79) for (var t=i; t <= val.mid; t++) {
            t = _LVAR([i])
            if EUDWhile()(t <= val.mid):
                def _t7():
                    t.__iadd__(1)
                # (Line 80) this.sorted[k] = this.array[t];
                _ARRW(this.sorted, k) << (this.array[t])
                # (Line 81) k++;
                k.__iadd__(1)
                # (Line 82) }
                # (Line 83) }
                EUDSetContinuePoint()
                _t7()
            EUDEndWhile()
            # (Line 84) Val.free(val);
        EUDEndIf()
        Val.free(val)
        # (Line 85) }
        # (Line 87) function sort() {

    @EUDMethod
    def sort(this):
        # (Line 88) this.divide(Val.alloc(0, this.length-1, 0));
        this.divide(Val.alloc(0, this.length - 1, 0))
        # (Line 89) while (this.stack2_ptr > 0) {
        if EUDWhile()(_ATTC(this, 'stack2_ptr') <= 0, neg=True):
            # (Line 90) this.stack2_ptr--;
            _ATTW(this, 'stack2_ptr').__isub__(1)
            # (Line 91) this.divide(this.stack2[this.stack2_ptr]);
            this.divide(this.stack2[this.stack2_ptr])
            # (Line 92) this.stack2[this.stack2_ptr] = 0;
            _ARRW(this.stack2, this.stack2_ptr) << (0)
            # (Line 93) }
            # (Line 95) while(this.stack1_ptr > 0) {
        EUDEndWhile()
        if EUDWhile()(_ATTC(this, 'stack1_ptr') <= 0, neg=True):
            # (Line 96) this.stack1_ptr--;
            _ATTW(this, 'stack1_ptr').__isub__(1)
            # (Line 97) this.merge(this.stack1[this.stack1_ptr]);
            this.merge(this.stack1[this.stack1_ptr])
            # (Line 98) this.stack1[this.stack1_ptr] = 0;
            _ARRW(this.stack1, this.stack1_ptr) << (0)
            # (Line 99) }
            # (Line 101) for(var i=0; i<this.length; i++) {
        EUDEndWhile()
        i = _LVAR([0])
        if EUDWhile()(i >= this.length, neg=True):
            def _t4():
                i.__iadd__(1)
            # (Line 102) simpleprint(this.sorted[i]);
            f_simpleprint(this.sorted[i])
            # (Line 103) }
            # (Line 104) }
            EUDSetContinuePoint()
            _t4()
        EUDEndWhile()
        # (Line 105) };

    _fields_ = [
        ('array', EUDArray),
        ('sorted', EUDArray),
        'length',
        'stack1_ptr',
        ('stack1', EUDArray),
        'stack2_ptr',
        ('stack2', EUDArray),
    ]

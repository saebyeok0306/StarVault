## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *
from eudplib.core.eudfunc import EUDTraceLog, EUDTracedFunc, EUDTracedTypedFunc, EUDTracedMethod, EUDTracedTypedMethod
from eudplib.epscript.helper import _RELIMP, _IGVA, _CGFW, _ARR, _VARR, _SRET, _SV, _ATTW, _ARRW, _ATTC, _ARRC, _L2V, _LVAR, _LSH, _ALL
# (Line 1) import Hash;
import Hash
# (Line 3) var sendflag;
sendflag = EUDVariable()
# (Line 5) var addr;
addr = EUDVariable()
# (Line 6) var ptrAddr;
ptrAddr = EUDVariable()
# (Line 7) var chatLen;
chatLen = EUDVariable()
# (Line 9) var chatHash1;
chatHash1 = EUDVariable()
# (Line 10) var chatHash2;
chatHash2 = EUDVariable()
# (Line 12) const syncChatHash1 = PVariable(list(-1,-1,-1,-1,-1,-1,-1,-1));
syncChatHash1 = _CGFW(lambda: [PVariable(FlattenList([-1, -1, -1, -1, -1, -1, -1, -1]))], 1)[0]
# (Line 13) const syncChatHash2 = PVariable(list(-1,-1,-1,-1,-1,-1,-1,-1));
syncChatHash2 = _CGFW(lambda: [PVariable(FlattenList([-1, -1, -1, -1, -1, -1, -1, -1]))], 1)[0]
# (Line 15) const TestDbs = [Db(218),Db(218),Db(218),Db(218),Db(218),Db(218),Db(218)];
TestDbs = _CGFW(lambda: [_ARR(FlattenList([Db(218), Db(218), Db(218), Db(218), Db(218), Db(218), Db(218)]))], 1)[0]
# (Line 17) const s = StringBuffer(1024);
s = _CGFW(lambda: [StringBuffer(1024)], 1)[0]
# (Line 18) const e = Hash.EUDHash();
e = _CGFW(lambda: [Hash.EUDHash()], 1)[0]
# (Line 20) function ChattingInit() {
@EUDFunc
def ChattingInit():
    # (Line 21) EUDRegisterObjectToNamespace("sendflag", sendflag);
    EUDRegisterObjectToNamespace("sendflag", sendflag)
    # (Line 22) EUDRegisterObjectToNamespace("addr", addr);
    EUDRegisterObjectToNamespace("addr", addr)
    # (Line 23) EUDRegisterObjectToNamespace("ptrAddr", ptrAddr);
    EUDRegisterObjectToNamespace("ptrAddr", ptrAddr)
    # (Line 24) EUDRegisterObjectToNamespace("chatLen", chatLen);
    EUDRegisterObjectToNamespace("chatLen", chatLen)
    # (Line 25) EUDRegisterObjectToNamespace("chatHash1", chatHash1);
    EUDRegisterObjectToNamespace("chatHash1", chatHash1)
    # (Line 26) EUDRegisterObjectToNamespace("chatHash2", chatHash2);
    EUDRegisterObjectToNamespace("chatHash2", chatHash2)
    # (Line 27) EUDRegisterObjectToNamespace("syncChatHash1", syncChatHash1);
    EUDRegisterObjectToNamespace("syncChatHash1", syncChatHash1)
    # (Line 28) EUDRegisterObjectToNamespace("syncChatHash2", syncChatHash2);
    EUDRegisterObjectToNamespace("syncChatHash2", syncChatHash2)
    # (Line 30) foreach(cp : EUDLoopPlayer("Human")) {
    for cp in EUDLoopPlayer("Human"):
        # (Line 31) setcurpl(cp);
        f_setcurpl(cp)
        # (Line 33) memcpy(TestDbs[cp], 0x57EEEB + 36 * cp, strlen(0x57EEEB + 36 * cp));
        f_memcpy(TestDbs[cp], 0x57EEEB + 36 * cp, f_strlen(0x57EEEB + 36 * cp))
        # (Line 34) }
        # (Line 35) }

    # (Line 42) function AllToChat() {

@EUDFunc
def AllToChat():
    # (Line 43) SetMemory(0x581D60, SetTo, 8);
    # (Line 44) if(Memory(0x68C144, AtLeast, 1)){
    DoActions(SetMemory(0x581D60, SetTo, 8))
    if EUDIf()(Memory(0x68C144, AtLeast, 1)):
        # (Line 45) SetMemory(0x68C144, SetTo, 2);
        # (Line 46) }
        DoActions(SetMemory(0x68C144, SetTo, 2))
        # (Line 47) }
    EUDEndIf()
    # (Line 49) function EncodeChat(hash, length) {

@EUDFunc
def EncodeChat(hash, length):
    # (Line 50) var half1, half2 = div(hash, 0x10000);
    half1, half2 = _LVAR([f_div(hash, 0x10000)])
    # (Line 51) half2 += (length << 16);
    half2.__iadd__((_LSH(length,16)))
    # (Line 52) return half1, half2;
    EUDReturn(half1, half2)
    # (Line 53) }
    # (Line 55) function DecodeChat(half1, half2) {

@EUDFunc
def DecodeChat(half1, half2):
    # (Line 56) var length;
    length = EUDVariable()
    # (Line 57) length, half2 = div(half2, 0x10000);
    _SV([length, half2], [f_div(half2, 0x10000)])
    # (Line 58) const hash = (half1 << 16) + half2;
    hash = (_LSH(half1,16)) + half2
    # (Line 59) return hash, length;
    EUDReturn(hash, length)
    # (Line 60) }
    # (Line 62) function ParseChat(hash, length) {

@EUDFunc
def ParseChat(hash, length):
    # (Line 63) const chatPtr = 0x640B60; // 218
    chatPtr = 0x640B60
    # (Line 64) const chatIdx = EPD(0x640B58);
    chatIdx = EPD(0x640B58)
    # (Line 66) for (var i=0; i<11; i++) {
    i = _LVAR([0])
    if EUDWhile()(i >= 11, neg=True):
        def _t2():
            i.__iadd__(1)
        # (Line 67) const targetPtr = chatPtr + 218*i;
        targetPtr = chatPtr + 218 * i
        # (Line 68) const br = EUDByteReader();
        br = EUDByteReader()
        # (Line 69) br.seekoffset(targetPtr);
        br.seekoffset(targetPtr)
        # (Line 71) var pos = 0;
        pos = _LVAR([0])
        # (Line 72) var flag = 0;
        flag = _LVAR([0])
        # (Line 73) while (true) {
        if EUDWhile()(True):
            # (Line 74) pos ++;
            pos.__iadd__(1)
            # (Line 75) const b = br.readbyte();
            b = br.readbyte()
            # (Line 76) switch (flag) {
            EUDSwitch(flag)
            # (Line 77) case 0:
            _t4 = EUDSwitchCase()
            # (Line 78) if(b == 58) flag = 1;
            if _t4(0):
                if EUDIf()(b == 58):
                    flag << (1)
                    # (Line 79) break;
                EUDEndIf()
                EUDBreak()
                # (Line 81) case 1:
            _t6 = EUDSwitchCase()
            # (Line 82) if(b == 32) flag = 2;
            if _t6(1):
                if EUDIf()(b == 32):
                    flag << (2)
                    # (Line 83) else if(b == 2) flag = 3;
                if EUDElseIf()(b == 2):
                    flag << (3)
                    # (Line 84) else flag = 0;
                if EUDElse()():
                    flag << (0)
                    # (Line 85) break;
                EUDEndIf()
                EUDBreak()
                # (Line 87) case 2:
            _t9 = EUDSwitchCase()
            # (Line 88) if(b == 7) flag = 15;
            if _t9(2):
                if EUDIf()(b == 7):
                    flag << (15)
                    # (Line 89) else flag = 0;
                if EUDElse()():
                    flag << (0)
                    # (Line 90) break;
                EUDEndIf()
                EUDBreak()
                # (Line 92) case 3:
            _t11 = EUDSwitchCase()
            # (Line 93) if(b == 32) flag = 15;
            if _t11(3):
                if EUDIf()(b == 32):
                    flag << (15)
                    # (Line 94) else flag = 0;
                if EUDElse()():
                    flag << (0)
                    # (Line 95) break;
                EUDEndIf()
                EUDBreak()
                # (Line 96) }
            # (Line 97) if (flag == 15) break;
            EUDEndSwitch()
            if EUDIf()(flag == 15):
                EUDBreak()
                # (Line 98) if (b == 0) break;
            EUDEndIf()
            if EUDIf()(b == 0):
                EUDBreak()
                # (Line 99) }
            EUDEndIf()
            # (Line 101) if (flag != 15) continue;
        EUDEndWhile()
        if EUDIf()(flag == 15, neg=True):
            EUDContinue()
            # (Line 102) const chattingPtr = targetPtr+pos;
        EUDEndIf()
        chattingPtr = targetPtr + pos
        # (Line 103) const _len = strlen(chattingPtr);
        _len = f_strlen(chattingPtr)
        # (Line 104) if (length != _len) continue;
        if EUDIf()(length == _len, neg=True):
            EUDContinue()
            # (Line 105) const _hash = e.hash(chattingPtr, _len, Hash.KEY1, Hash.KEY2);
        EUDEndIf()
        _hash = e.hash(chattingPtr, _len, Hash.KEY1, Hash.KEY2)
        # (Line 106) if (_hash != hash) continue;
        if EUDIf()(_hash == hash, neg=True):
            EUDContinue()
            # (Line 107) return chattingPtr;
        EUDEndIf()
        EUDReturn(chattingPtr)
        # (Line 108) }
        # (Line 110) return -1;
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
    EUDReturn(-1)
    # (Line 111) }
    # (Line 113) function ChattingExec() {

@EUDFunc
def ChattingExec():
    # (Line 114) AllToChat();
    AllToChat()
    # (Line 117) if(addr > 0) {
    if EUDIf()(addr <= 0, neg=True):
        # (Line 118) sendflag = 1;
        sendflag << (1)
        # (Line 119) const o = e.hash(ptrAddr, chatLen, Hash.KEY1, Hash.KEY2);
        o = e.hash(ptrAddr, chatLen, Hash.KEY1, Hash.KEY2)
        # (Line 120) chatHash1, chatHash2 = EncodeChat(o, chatLen);
        _SV([chatHash1, chatHash2], [EncodeChat(o, chatLen)])
        # (Line 121) }
        # (Line 122) else if(sendflag) sendflag = 0;
    if EUDElseIf()(sendflag):
        sendflag << (0)
        # (Line 125) foreach(cp : EUDLoopPlayer("Human")) {
    EUDEndIf()
    for cp in EUDLoopPlayer("Human"):
        # (Line 126) setcurpl(cp);
        f_setcurpl(cp)
        # (Line 128) if(syncChatHash1[cp] != -1 || syncChatHash2[cp] != -1) {
        if EUDIf()(EUDSCOr()(_ARRC(syncChatHash1, cp) == -1, neg=True)(_ARRC(syncChatHash2, cp) == -1, neg=True)()):
            # (Line 129) if(syncChatHash1[cp] != -1 && syncChatHash2[cp] != -1) {
            if EUDIf()(EUDSCAnd()(_ARRC(syncChatHash1, cp) == -1, neg=True)(_ARRC(syncChatHash2, cp) == -1, neg=True)()):
                # (Line 130) const hash, length = DecodeChat(syncChatHash1[cp], syncChatHash2[cp]);
                hash, length = List2Assignable([DecodeChat(syncChatHash1[cp], syncChatHash2[cp])])
                # (Line 131) s.printf("msqc: {} {}", syncChatHash1[cp], syncChatHash2[cp]);
                s.printf("msqc: {} {}", syncChatHash1[cp], syncChatHash2[cp])
                # (Line 132) s.printf("hash: {} length: {}", hash, length);
                s.printf("hash: {} length: {}", hash, length)
                # (Line 133) const chatPtr = ParseChat(hash, length);
                chatPtr = ParseChat(hash, length)
                # (Line 134) s.printf("chatPtr: 0x{:x}", chatPtr);
                s.printf("chatPtr: 0x{:x}", chatPtr)
                # (Line 135) if(chatPtr != -1) {
                if EUDIf()(chatPtr == -1, neg=True):
                    # (Line 136) memcpy(TestDbs[cp], chatPtr, length);
                    f_memcpy(TestDbs[cp], chatPtr, length)
                    # (Line 137) sprintf(TestDbs[cp]+length, "\0");
                    f_sprintf(TestDbs[cp] + length, "\0")
                    # (Line 138) SetResources(Force1, SetTo, dwread(chatPtr), Ore);
                    # (Line 139) }
                    DoActions(SetResources(Force1, SetTo, f_dwread(chatPtr), Ore))
                    # (Line 140) else {
                if EUDElse()():
                    # (Line 142) s.printf("데이터가 누락되었습니다.");
                    s.printf("데이터가 누락되었습니다.")
                    # (Line 143) }
                    # (Line 144) }
                EUDEndIf()
                # (Line 145) else {
            if EUDElse()():
                # (Line 147) s.printf("데이터가 누락되었습니다.");
                s.printf("데이터가 누락되었습니다.")
                # (Line 148) }
                # (Line 149) }
            EUDEndIf()
            # (Line 151) const t = StringBuffer(1024);
        EUDEndIf()
        t = StringBuffer(1024)
        # (Line 152) t.insert(0);
        t.insert(0)
        # (Line 153) foreach(tp : EUDLoopPlayer("Human")) {
        for tp in EUDLoopPlayer("Human"):
            # (Line 154) t.appendf("{0:s}(src:0x{0:x}) ", TestDbs[tp]);
            t.appendf("{0:s}(src:0x{0:x}) ", TestDbs[tp])
            # (Line 155) }
            # (Line 156) eprintf("{:t}", t.epd);

        f_eprintf("{:t}", t.epd)
        # (Line 157) }
        # (Line 158) }

    # (Line 161) function ChattingAfterExec() {

@EUDFunc
def ChattingAfterExec():
    # (Line 162) foreach(cp : EUDLoopPlayer("Human")) {
    for cp in EUDLoopPlayer("Human"):
        # (Line 163) setcurpl(cp);
        f_setcurpl(cp)
        # (Line 164) SetPNamef(cp, "{:c}{:s}", cp, TestDbs[cp]);
        SetPNamef(cp, "{:c}{:s}", cp, TestDbs[cp])
        # (Line 165) }
        # (Line 166) }

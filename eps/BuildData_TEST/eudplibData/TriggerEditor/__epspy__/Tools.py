## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *
from eudplib.core.eudfunc import EUDTraceLog, EUDTracedFunc, EUDTracedTypedFunc, EUDTracedMethod, EUDTracedTypedMethod
from eudplib.epscript.helper import _RELIMP, _IGVA, _CGFW, _ARR, _VARR, _SRET, _SV, _ATTW, _ARRW, _ATTC, _ARRC, _L2V, _LVAR, _LSH, _ALL
# (Line 3) const loc_table = EPD(0x58DC4C);
loc_table = _CGFW(lambda: [EPD(0x58DC4C)], 1)[0]
# (Line 4) var button_refresh_request = 0;
button_refresh_request = _IGVA(1, lambda: [0])
# (Line 6) const NEXT_UNIT_OFFSET  = EPD(0x628438);
NEXT_UNIT_OFFSET = _CGFW(lambda: [EPD(0x628438)], 1)[0]
# (Line 8) function SetNextUnitPTR(){
@EUDFunc
def SetNextUnitPTR():
    # (Line 9) return cunitepdread_epd(NEXT_UNIT_OFFSET)[[0]];
    EUDReturn(f_cunitepdread_epd(NEXT_UNIT_OFFSET)[0])
    # (Line 10) }
    # (Line 12) function SetNextUnitEPD(){

@EUDFunc
def SetNextUnitEPD():
    # (Line 13) return cunitepdread_epd(NEXT_UNIT_OFFSET)[[1]];
    EUDReturn(f_cunitepdread_epd(NEXT_UNIT_OFFSET)[1])
    # (Line 14) }
    # (Line 16) function SetNextUnit(){

@EUDFunc
def SetNextUnit():
    # (Line 17) return cunitepdread_epd(NEXT_UNIT_OFFSET);
    EUDReturn(f_cunitepdread_epd(NEXT_UNIT_OFFSET))
    # (Line 18) }
    # (Line 20) function IndexToEPD(index){

@EUDFunc
def IndexToEPD(index):
    # (Line 21) if(index == 0) {
    if EUDIf()(index == 0):
        # (Line 22) return 19025;
        EUDReturn(19025)
        # (Line 23) } else {
    if EUDElse()():
        # (Line 24) return 161825 - (84 * index);
        EUDReturn(161825 - (84 * index))
        # (Line 25) }
        # (Line 26) }
    EUDEndIf()
    # (Line 28) function ButtonRefresh(){

@EUDFunc
def ButtonRefresh():
    # (Line 29) button_refresh_request = 1;
    button_refresh_request << (1)
    # (Line 30) }
    # (Line 32) function ButtonRefreshExec(){

@EUDFunc
def ButtonRefreshExec():
    # (Line 33) if(button_refresh_request){
    if EUDIf()(button_refresh_request):
        # (Line 34) button_refresh_request = 0;
        button_refresh_request << (0)
        # (Line 35) const epd = SetNextUnitEPD();
        epd = SetNextUnitEPD()
        # (Line 36) CreateUnit(1, 45, "Map_Create_Temp_2", P7);
        # (Line 37) SetMemoryXEPD(epd+0x110/4, SetTo, 1, 0xFFFF);
        DoActions(CreateUnit(1, 45, "Map_Create_Temp_2", P7))
        # (Line 38) }
        DoActions(SetMemoryXEPD(epd + 0x110 // 4, SetTo, 1, 0xFFFF))
        # (Line 39) }
    EUDEndIf()
    # (Line 41) function ScanEffect(targetLoc:TrgLocation, targetImage){

@EUDTypedFunc([TrgLocation, None])
def ScanEffect(targetLoc, targetImage):
    # (Line 42) SetMemoryX(0x666458, SetTo, targetImage, 0xFFFF);
    # (Line 43) CreateUnit(1, 33, targetLoc, 7);
    DoActions(SetMemoryX(0x666458, SetTo, targetImage, 0xFFFF))
    # (Line 44) }
    DoActions(CreateUnit(1, 33, targetLoc, 7))
    # (Line 46) function AsyncScanEffect(loc:TrgLocation, image){

@EUDTypedFunc([TrgLocation, None])
def AsyncScanEffect(loc, image):
    # (Line 47) once {
    _t1 = EUDExecuteOnce()
    if _t1():
        # (Line 48) SetMemoryXEPD(EPD(0x661518 + 33 * 2), SetTo, 2*0x10000, 0xFFFF0000); // Staredit_Availability_Flags
        # (Line 49) SetMemory(0x664080 + 33 * 4, SetTo, 0x18000004); // Special_Ability_Flags
        DoActions(SetMemoryXEPD(EPD(0x661518 + 33 * 2), SetTo, 2 * 0x10000, 0xFFFF0000))
        # (Line 50) SetMemoryXEPD(EPD(0x662268 + 33), SetTo, 0, 0xFF00); // Human AI
        DoActions(SetMemory(0x664080 + 33 * 4, SetTo, 0x18000004))
        # (Line 51) SetMemoryXEPD(EPD(0x662EA0 + 33), SetTo, 0, 0xFF00); // Computer AI
        DoActions(SetMemoryXEPD(EPD(0x662268 + 33), SetTo, 0, 0xFF00))
        # (Line 52) SetMemoryXEPD(EPD(0x6617C8 + 33 * 8), SetTo, 1, 0xFFFF); // Unit Size Left
        DoActions(SetMemoryXEPD(EPD(0x662EA0 + 33), SetTo, 0, 0xFF00))
        # (Line 53) SetMemoryXEPD(EPD(0x6617CA + 33 * 8), SetTo, 1, 0xFFFF); // Unit Size Up
        DoActions(SetMemoryXEPD(EPD(0x6617C8 + 33 * 8), SetTo, 1, 0xFFFF))
        # (Line 54) SetMemoryXEPD(EPD(0x6617CC + 33 * 8), SetTo, 1, 0xFFFF); // Unit Size Right
        DoActions(SetMemoryXEPD(EPD(0x6617CA + 33 * 8), SetTo, 1, 0xFFFF))
        # (Line 55) SetMemoryXEPD(EPD(0x6617CE + 33 * 8), SetTo, 1, 0xFFFF); // Unit Size Down
        DoActions(SetMemoryXEPD(EPD(0x6617CC + 33 * 8), SetTo, 1, 0xFFFF))
        # (Line 56) }
        DoActions(SetMemoryXEPD(EPD(0x6617CE + 33 * 8), SetTo, 1, 0xFFFF))
        # (Line 57) const offset = EPD(0x665DC4); // scan visible option
    EUDEndExecuteOnce()
    offset = EPD(0x665DC4)
    # (Line 58) SetMemoryXEPD(offset, SetTo, 0, 0xFF); // Sync Visible 0
    # (Line 59) if(IsUserCP()) SetMemoryXEPD(offset, SetTo, 1, 0xFF); // Async Visible 1
    DoActions(SetMemoryXEPD(offset, SetTo, 0, 0xFF))
    if EUDIf()(IsUserCP()):
        # (Line 60) SetMemoryX(0x666458, SetTo, image, 0xFFFF);
        DoActions(SetMemoryXEPD(offset, SetTo, 1, 0xFF))
    EUDEndIf()
    # (Line 61) CreateUnit(1, 33, loc, 7);
    DoActions(SetMemoryX(0x666458, SetTo, image, 0xFFFF))
    # (Line 62) SetMemoryXEPD(offset, SetTo, 1, 0xFF);  // Sync Visible 1
    DoActions(CreateUnit(1, 33, loc, 7))
    # (Line 63) }
    DoActions(SetMemoryXEPD(offset, SetTo, 1, 0xFF))
    # (Line 66) function OnlyVisibleMe() {

@EUDFunc
def OnlyVisibleMe():
    # (Line 67) SetMemoryXEPD(EPD(0x665C48 + 380), SetTo, 0, 0xFF);
    # (Line 68) if(IsUserCP()) SetMemoryXEPD(EPD(0x665C48 + 380), SetTo, 1, 0xFF);
    DoActions(SetMemoryXEPD(EPD(0x665C48 + 380), SetTo, 0, 0xFF))
    if EUDIf()(IsUserCP()):
        # (Line 69) }
        DoActions(SetMemoryXEPD(EPD(0x665C48 + 380), SetTo, 1, 0xFF))
    EUDEndIf()
    # (Line 71) function OnlyVisibleMe2(sprite) {

@EUDFunc
def OnlyVisibleMe2(sprite):
    # (Line 72) bwrite(0x665C48 + sprite, 0);
    f_bwrite(0x665C48 + sprite, 0)
    # (Line 73) if(IsUserCP()) bwrite(0x665C48 + sprite, 1);
    if EUDIf()(IsUserCP()):
        f_bwrite(0x665C48 + sprite, 1)
        # (Line 74) }
    EUDEndIf()
    # (Line 77) function SingleBan(){

@EUDFunc
def SingleBan():
    # (Line 78) const a = 0x6D0F48; //방이름
    a = 0x6D0F48
    # (Line 79) const b = 0x6D0F78; //방장닉
    b = 0x6D0F78
    # (Line 80) const c = Db("");
    c = Db("")
    # (Line 81) if(strcmp(b, Db("PLAYTESTACC")) == 0) return;
    if EUDIf()(f_strcmp(b, Db("PLAYTESTACC")) == 0):
        EUDReturn()
        # (Line 82) if(strcmp(a, b) == 0){
    EUDEndIf()
    if EUDIf()(f_strcmp(a, b) == 0):
        # (Line 83) foreach(cp : EUDLoopPlayer('Human')){
        for cp in EUDLoopPlayer('Human'):
            # (Line 84) setcurpl(cp); DisplayText("\x13\x08UDP \x04환경에서의 게임플레이는 금지하고 있습니다.\n\x13\x1C배틀넷\x04에서 게임을 진행해주세요.");
            f_setcurpl(cp)
            # (Line 85) if(IsUserCP()){if(Memory(0x000000, Exactly, 0)){Defeat();}}}
            DoActions(DisplayText("\x13\x08UDP \x04환경에서의 게임플레이는 금지하고 있습니다.\n\x13\x1C배틀넷\x04에서 게임을 진행해주세요."))
            if EUDIf()(IsUserCP()):
                if EUDIf()(Memory(0x000000, Exactly, 0)):
                    DoActions(Defeat())
                EUDEndIf()
            EUDEndIf()
            # (Line 86) }

        # (Line 87) else if(strcmp(b, c) == 0){
    if EUDElseIf()(f_strcmp(b, c) == 0):
        # (Line 88) foreach(cp : EUDLoopPlayer('Human')){
        for cp in EUDLoopPlayer('Human'):
            # (Line 89) setcurpl(cp); DisplayText("\x13\x08싱글 \x04환경에서의 게임플레이는 금지하고 있습니다.\n\x13\x1C배틀넷\x04에서 게임을 진행해주세요.");
            f_setcurpl(cp)
            # (Line 90) if(IsUserCP()){if(Memory(0x000000, Exactly, 0)){Defeat();}}}
            DoActions(DisplayText("\x13\x08싱글 \x04환경에서의 게임플레이는 금지하고 있습니다.\n\x13\x1C배틀넷\x04에서 게임을 진행해주세요."))
            if EUDIf()(IsUserCP()):
                if EUDIf()(Memory(0x000000, Exactly, 0)):
                    DoActions(Defeat())
                EUDEndIf()
            EUDEndIf()
            # (Line 91) }

        # (Line 92) else if(Deaths(Force1, Exactly, 1, "Defeat")) {
    if EUDElseIf()(Deaths(Force1, Exactly, 1, "Defeat")):
        # (Line 93) foreach(cp : EUDLoopPlayer('Human')){
        for cp in EUDLoopPlayer('Human'):
            # (Line 94) setcurpl(cp); DisplayText("\x13\x04최소 2명 이상의 인원으로 게임을 시작해야 합니다.");
            f_setcurpl(cp)
            # (Line 95) if(IsUserCP()){if(Memory(0x000000, Exactly, 0)){Defeat();}}}
            DoActions(DisplayText("\x13\x04최소 2명 이상의 인원으로 게임을 시작해야 합니다."))
            if EUDIf()(IsUserCP()):
                if EUDIf()(Memory(0x000000, Exactly, 0)):
                    DoActions(Defeat())
                EUDEndIf()
            EUDEndIf()
            # (Line 96) }

        # (Line 97) }
    EUDEndIf()
    # (Line 99) function SpeedBan(){

@EUDFunc
def SpeedBan():
    # (Line 100) const a = dwread_epd(EPD(0x51CE84));
    a = f_dwread_epd(EPD(0x51CE84))
    # (Line 101) const b = dwread_epd(EPD(0x51CE88));
    b = f_dwread_epd(EPD(0x51CE88))
    # (Line 102) if(a == 1000){if(b == 1000) return;}		//턴레이트24
    if EUDIf()(a == 1000):
        if EUDIf()(b == 1000):
            EUDReturn()
        EUDEndIf()
        # (Line 103) else if(a == 1042){if(b == 1190) return;}	//턴레이트20
    if EUDElseIf()(a == 1042):
        if EUDIf()(b == 1190):
            EUDReturn()
        EUDEndIf()
        # (Line 104) else if(a == 1302){if(b == 1488) return;}	//턴레이트16
    if EUDElseIf()(a == 1302):
        if EUDIf()(b == 1488):
            EUDReturn()
        EUDEndIf()
        # (Line 105) else if(a == 1488){if(b == 1701) return;}	//턴레이트14
    if EUDElseIf()(a == 1488):
        if EUDIf()(b == 1701):
            EUDReturn()
        EUDEndIf()
        # (Line 106) else if(a == 1736){if(b == 1984) return;}	//턴레이트12
    if EUDElseIf()(a == 1736):
        if EUDIf()(b == 1984):
            EUDReturn()
        EUDEndIf()
        # (Line 107) else if(a == 2083){if(b == 2381) return;}	//턴레이트10
    if EUDElseIf()(a == 2083):
        if EUDIf()(b == 2381):
            EUDReturn()
        EUDEndIf()
        # (Line 108) else if(a == 2604){if(b == 2976) return;}	//턴레이트8
    if EUDElseIf()(a == 2604):
        if EUDIf()(b == 2976):
            EUDReturn()
        EUDEndIf()
        # (Line 109) else{
    if EUDElse()():
        # (Line 110) foreach(cp : EUDLoopPlayer('Human', None, None)){
        for cp in EUDLoopPlayer('Human', None, None):
            # (Line 111) setcurpl(cp);
            f_setcurpl(cp)
            # (Line 112) DisplayText("\x13\x1D방제 배속\x04을 막아두고 있습니다.\n\x13\x04방제목에 있는 \x08배속(#x2)\x04을 지워서 다시 방을 생성해주세요.");
            # (Line 113) Defeat();
            DoActions(DisplayText("\x13\x1D방제 배속\x04을 막아두고 있습니다.\n\x13\x04방제목에 있는 \x08배속(#x2)\x04을 지워서 다시 방을 생성해주세요."))
            # (Line 114) }
            DoActions(Defeat())
            # (Line 115) }

        # (Line 116) }
    EUDEndIf()
    # (Line 118) function CheckFastest(){

@EUDFunc
def CheckFastest():
    # (Line 119) if(!MemoryXEPD(EPD(0x6D0F6A), Exactly, 0x60000, 0xF0000)){
    if EUDIf()(MemoryXEPD(EPD(0x6D0F6A), Exactly, 0x60000, 0xF0000), neg=True):
        # (Line 121) foreach(cp : EUDLoopPlayer("Human")){
        for cp in EUDLoopPlayer("Human"):
            # (Line 122) setcurpl(cp);
            f_setcurpl(cp)
            # (Line 123) DisplayText("\x13\x04방설정에서 게임속도를\n\x13\x11가장빠름(Fastest)\x04으로 설정해주세요.");
            # (Line 124) Defeat();
            DoActions(DisplayText("\x13\x04방설정에서 게임속도를\n\x13\x11가장빠름(Fastest)\x04으로 설정해주세요."))
            # (Line 125) }
            DoActions(Defeat())
            # (Line 126) }

        # (Line 127) }
    EUDEndIf()
    # (Line 129) function CheckPlayer(player){

@EUDFunc
def CheckPlayer(player):
    # (Line 130) if(!MemoryX(0x57EEE8+ 0x24*player, Exactly, 2, 0x000000FF)){ //해당플레이어가 유저가 아닌 경우
    if EUDIf()(MemoryX(0x57EEE8 + 0x24 * player, Exactly, 2, 0x000000FF), neg=True):
        # (Line 131) EUDPlayerLoop()();
        EUDPlayerLoop()()
        # (Line 132) if(IsUserCP()){if(Memory(0x000000, Exactly, 0)){Defeat();}}
        if EUDIf()(IsUserCP()):
            if EUDIf()(Memory(0x000000, Exactly, 0)):
                DoActions(Defeat())
            EUDEndIf()
            # (Line 133) EUDEndPlayerLoop();
        EUDEndIf()
        EUDEndPlayerLoop()
        # (Line 134) }
        # (Line 135) }
    EUDEndIf()
    # (Line 137) function CheckComputer(player){

@EUDFunc
def CheckComputer(player):
    # (Line 138) if(MemoryX(0x57EEE8+ 0x24*player, Exactly, 2, 0x000000FF)){ //해당플레이어가 유저인 경우
    if EUDIf()(MemoryX(0x57EEE8 + 0x24 * player, Exactly, 2, 0x000000FF)):
        # (Line 139) EUDPlayerLoop()();
        EUDPlayerLoop()()
        # (Line 140) if(IsUserCP()){if(Memory(0x000000, Exactly, 0)){Defeat();}}
        if EUDIf()(IsUserCP()):
            if EUDIf()(Memory(0x000000, Exactly, 0)):
                DoActions(Defeat())
            EUDEndIf()
            # (Line 141) EUDEndPlayerLoop();
        EUDEndIf()
        EUDEndPlayerLoop()
        # (Line 142) }
        # (Line 143) }
    EUDEndIf()
    # (Line 145) function Moderator(){

@EUDFunc
def Moderator():
    # (Line 146) const b = 0x6D0F78; //방장닉
    b = 0x6D0F78
    # (Line 147) foreach(cp : EUDLoopPlayer('Human')){
    for cp in EUDLoopPlayer('Human'):
        # (Line 148) const d = 0x57EEEB + 36 * cp;
        d = 0x57EEEB + 36 * cp
        # (Line 149) if(strcmp(b, d) == 0){
        if EUDIf()(f_strcmp(b, d) == 0):
            # (Line 150) return cp;
            EUDReturn(cp)
            # (Line 151) }
            # (Line 152) }
        EUDEndIf()
        # (Line 153) return -1;

    EUDReturn(-1)
    # (Line 154) }
    # (Line 156) function BuildResetXEPD(unitEPD){

@EUDFunc
def BuildResetXEPD(unitEPD):
    # (Line 157) SetMemoryXEPD(unitEPD + 38, SetTo, 14942436, 0xFFFFFFFF);
    # (Line 158) SetMemoryXEPD(unitEPD + 39, SetTo, 14942436, 0xFFFFFFFF);
    DoActions(SetMemoryXEPD(unitEPD + 38, SetTo, 14942436, 0xFFFFFFFF))
    # (Line 159) SetMemoryXEPD(unitEPD + 40, SetTo, 228, 0xFFFF);
    DoActions(SetMemoryXEPD(unitEPD + 39, SetTo, 14942436, 0xFFFFFFFF))
    # (Line 160) SetMemoryXEPD(unitEPD + 41, SetTo, 131072, 0xFFFF0000);
    DoActions(SetMemoryXEPD(unitEPD + 40, SetTo, 228, 0xFFFF))
    # (Line 161) }
    DoActions(SetMemoryXEPD(unitEPD + 41, SetTo, 131072, 0xFFFF0000))
    # (Line 163) function BuildResetXEPD_Building(unitEPD)

# (Line 164) {
@EUDFunc
def BuildResetXEPD_Building(unitEPD):
    # (Line 165) BuildResetXEPD(unitEPD);
    BuildResetXEPD(unitEPD)
    # (Line 166) const currentBuildUnit = unitEPD + 0xEC/4;
    currentBuildUnit = unitEPD + 0xEC // 4
    # (Line 167) if (MemoryEPD(currentBuildUnit, AtLeast, 0x59CCA8))
    if EUDIf()(MemoryEPD(currentBuildUnit, AtLeast, 0x59CCA8)):
        # (Line 168) {  // 생산 중인 유닛이 있으면 삭제한다
        # (Line 169) const buildUnit = epdcunitread_epd(currentBuildUnit);
        buildUnit = f_epdcunitread_epd(currentBuildUnit)
        # (Line 170) SetMemoryXEPD(buildUnit+0x4D/4, SetTo, 0, 0xFF00);
        # (Line 171) }
        DoActions(SetMemoryXEPD(buildUnit + 0x4D // 4, SetTo, 0, 0xFF00))
        # (Line 172) }
    EUDEndIf()
    # (Line 174) function BuildCheckXEPD(unitEPD, Unit){

@EUDFunc
def BuildCheckXEPD(unitEPD, Unit):
    # (Line 175) const mulUnit = Unit*65536;
    mulUnit = Unit * 65536
    # (Line 176) if(MemoryXEPD(unitEPD + 38, Exactly, Unit, 0xFFFF)){return True;}
    if EUDIf()(MemoryXEPD(unitEPD + 38, Exactly, Unit, 0xFFFF)):
        EUDReturn(True)
        # (Line 177) else if(MemoryXEPD(unitEPD + 38, Exactly, mulUnit, 0xFFFF0000)){return True;}
    if EUDElseIf()(MemoryXEPD(unitEPD + 38, Exactly, mulUnit, 0xFFFF0000)):
        EUDReturn(True)
        # (Line 178) else if(MemoryXEPD(unitEPD + 39, Exactly, Unit, 0xFFFF)){return True;}
    if EUDElseIf()(MemoryXEPD(unitEPD + 39, Exactly, Unit, 0xFFFF)):
        EUDReturn(True)
        # (Line 179) else if(MemoryXEPD(unitEPD + 39, Exactly, mulUnit, 0xFFFF0000)){return True;}
    if EUDElseIf()(MemoryXEPD(unitEPD + 39, Exactly, mulUnit, 0xFFFF0000)):
        EUDReturn(True)
        # (Line 180) else if(MemoryXEPD(unitEPD + 40, Exactly, Unit, 0xFFFF)){return True;}
    if EUDElseIf()(MemoryXEPD(unitEPD + 40, Exactly, Unit, 0xFFFF)):
        EUDReturn(True)
        # (Line 181) else{return False;};
    if EUDElse()():
        EUDReturn(False)
    EUDEndIf()
    # (Line 182) }
    # (Line 184) function BuildCheckAtLeastXEPD(unitEPD){

@EUDFunc
def BuildCheckAtLeastXEPD(unitEPD):
    # (Line 185) if(!MemoryXEPD(unitEPD + 38, Exactly, 0xE4, 0xFFFF)){return True;}
    if EUDIf()(MemoryXEPD(unitEPD + 38, Exactly, 0xE4, 0xFFFF), neg=True):
        EUDReturn(True)
        # (Line 186) else if(!MemoryXEPD(unitEPD + 38, Exactly, 0xE40000, 0xFFFF0000)){return True;}
    if EUDElseIf()(MemoryXEPD(unitEPD + 38, Exactly, 0xE40000, 0xFFFF0000), neg=True):
        EUDReturn(True)
        # (Line 187) else if(!MemoryXEPD(unitEPD + 39, Exactly, 0xE4, 0xFFFF)){return True;}
    if EUDElseIf()(MemoryXEPD(unitEPD + 39, Exactly, 0xE4, 0xFFFF), neg=True):
        EUDReturn(True)
        # (Line 188) else if(!MemoryXEPD(unitEPD + 39, Exactly, 0xE40000, 0xFFFF0000)){return True;}
    if EUDElseIf()(MemoryXEPD(unitEPD + 39, Exactly, 0xE40000, 0xFFFF0000), neg=True):
        EUDReturn(True)
        # (Line 189) else if(!MemoryXEPD(unitEPD + 40, Exactly, 0xE4, 0xFFFF)){return True;}
    if EUDElseIf()(MemoryXEPD(unitEPD + 40, Exactly, 0xE4, 0xFFFF), neg=True):
        EUDReturn(True)
        # (Line 190) else{return False;};
    if EUDElse()():
        EUDReturn(False)
    EUDEndIf()
    # (Line 191) }
    # (Line 193) function HotkeyUnitEPD(epd, hotkey, slot) {

@EUDFunc
def HotkeyUnitEPD(epd, hotkey, slot):
    # (Line 195) epd += 0x4C / 4;
    epd.__iadd__(0x4C // 4)
    # (Line 196) const player = maskread_cp(0, 0xF);
    player = f_maskread_cp(0, 0xF)
    # (Line 197) epd += (0xA5-0x4C) / 4;
    epd.__iadd__((0xA5 - 0x4C) // 4)
    # (Line 198) const tosread_epd = readgen_epd(0xFF00, list(0, py_eval('lambda x: 8*x')));
    tosread_epd = f_readgen_epd(0xFF00, FlattenList([0, eval('lambda x: 8*x')]))
    # (Line 199) const alphaID = tosread_epd(epd);
    alphaID = tosread_epd(epd)
    # (Line 200) if (epd == 19025 + 0xA5/4) {
    if EUDIf()(epd == 19025 + 0xA5 // 4):
        # (Line 201) DoActions(alphaID.AddNumber(1));
        DoActions(alphaID.AddNumber(1))
        # (Line 202) } else {
    if EUDElse()():
        # (Line 203) const diff = 1701 - (161866 - epd) / 84;
        diff = 1701 - (161866 - epd) // 84
        # (Line 204) VProc(diff, diff.QueueAddTo(alphaID));
        VProc(diff, diff.QueueAddTo(alphaID))
        # (Line 205) }
        # (Line 206) SetDeaths(EPD(0x57FE60) + 216 * player + slot, SetTo, alphaID, hotkey);
    EUDEndIf()
    # (Line 207) }
    DoActions(SetDeaths(EPD(0x57FE60) + 216 * player + slot, SetTo, alphaID, hotkey))
    # (Line 209) function GetDeath(player:TrgPlayer, unit:TrgUnit){

@EUDTypedFunc([TrgPlayer, TrgUnit])
def GetDeath(player, unit):
    # (Line 210) return dwread_epd(player + 12 * unit);
    EUDReturn(f_dwread_epd(player + 12 * unit))
    # (Line 211) }
    # (Line 213) function SetPlayerColor(player:TrgPlayer, color){

@EUDTypedFunc([TrgPlayer, None])
def SetPlayerColor(player, color):
    # (Line 214) const pcolor_dst = 0x581D76 + 8 * player;
    pcolor_dst = 0x581D76 + 8 * player
    # (Line 215) const mcolor_dst = 0x581DD6 + player;
    mcolor_dst = 0x581DD6 + player
    # (Line 216) bwrite(pcolor_dst, color);
    f_bwrite(pcolor_dst, color)
    # (Line 217) bwrite(mcolor_dst, color);
    f_bwrite(mcolor_dst, color)
    # (Line 218) }
    # (Line 220) function SetUnitColor(UnitEPD, Color:TrgPlayer){

@EUDTypedFunc([None, TrgPlayer])
def SetUnitColor(UnitEPD, Color):
    # (Line 221) const spritePTR = dwread_epd(UnitEPD + 0xC/4);
    spritePTR = f_dwread_epd(UnitEPD + 0xC // 4)
    # (Line 222) bwrite(spritePTR + 0x0A, Color);
    f_bwrite(spritePTR + 0x0A, Color)
    # (Line 223) }
    # (Line 225) function SetUnitSize(unitType, unitSize)

# (Line 226) {
@EUDFunc
def SetUnitSize(unitType, unitSize):
    # (Line 227) const unit_type_4 = unitType * 4;
    unit_type_4 = unitType * 4
    # (Line 228) const unit_type_8 = unit_type_4 * 2;
    unit_type_8 = unit_type_4 * 2
    # (Line 229) wwrite(0x6617C8 + unit_type_8, unitSize); // Size Left
    f_wwrite(0x6617C8 + unit_type_8, unitSize)
    # (Line 230) wwrite(0x6617CA + unit_type_8, unitSize); // Size Up
    f_wwrite(0x6617CA + unit_type_8, unitSize)
    # (Line 231) wwrite(0x6617CC + unit_type_8, unitSize); // Size Right
    f_wwrite(0x6617CC + unit_type_8, unitSize)
    # (Line 232) wwrite(0x6617CE + unit_type_8, unitSize); // Size Down
    f_wwrite(0x6617CE + unit_type_8, unitSize)
    # (Line 234) SetMemory(0x662860 + unit_type_4, SetTo, (unitSize << 16) + unitSize);
    # (Line 235) }
    DoActions(SetMemory(0x662860 + unit_type_4, SetTo, (_LSH(unitSize,16)) + unitSize))
    # (Line 237) function SetUnitSizeLURD(unitType, l, u, r, d)

# (Line 238) {
@EUDFunc
def SetUnitSizeLURD(unitType, l, u, r, d):
    # (Line 239) const unit_type_4 = unitType * 4;
    unit_type_4 = unitType * 4
    # (Line 240) const unit_type_8 = unit_type_4 * 2;
    unit_type_8 = unit_type_4 * 2
    # (Line 241) wwrite(0x6617C8 + unit_type_8, l); // Size Left
    f_wwrite(0x6617C8 + unit_type_8, l)
    # (Line 242) wwrite(0x6617CA + unit_type_8, u); // Size Up
    f_wwrite(0x6617CA + unit_type_8, u)
    # (Line 243) wwrite(0x6617CC + unit_type_8, r); // Size Right
    f_wwrite(0x6617CC + unit_type_8, r)
    # (Line 244) wwrite(0x6617CE + unit_type_8, d); // Size Down
    f_wwrite(0x6617CE + unit_type_8, d)
    # (Line 246) SetMemory(0x662860 + unit_type_4, SetTo, ((u+d) << 16) + l+r);
    # (Line 247) }
    DoActions(SetMemory(0x662860 + unit_type_4, SetTo, (_LSH((u + d),16)) + l + r))
    # (Line 249) function GetUnitNumber(player:TrgPlayer, unit:TrgUnit){

@EUDTypedFunc([TrgPlayer, TrgUnit])
def GetUnitNumber(player, unit):
    # (Line 250) return dwread_epd(EPD(0x582324)+player+12*unit);
    EUDReturn(f_dwread_epd(EPD(0x582324) + player + 12 * unit))
    # (Line 251) }
    # (Line 253) function IsRequirement(player:TrgPlayer, unit:TrgUnit, value){

@EUDTypedFunc([TrgPlayer, TrgUnit, None])
def IsRequirement(player, unit, value):
    # (Line 254) if(MemoryEPD(EPD(0x584DE4)+(12*unit)+player, Exactly, value)){return true;}
    if EUDIf()(MemoryEPD(EPD(0x584DE4) + (12 * unit) + player, Exactly, value)):
        EUDReturn(True)
        # (Line 255) return false;
    EUDEndIf()
    EUDReturn(False)
    # (Line 256) }
    # (Line 258) function SetRequirement(player:TrgPlayer, unit:TrgUnit, value){

@EUDTypedFunc([TrgPlayer, TrgUnit, None])
def SetRequirement(player, unit, value):
    # (Line 259) SetMemoryEPD(EPD(0x584DE4)+(12*unit)+player, SetTo, value);
    # (Line 260) }
    DoActions(SetMemoryEPD(EPD(0x584DE4) + (12 * unit) + player, SetTo, value))
    # (Line 262) function Hypot(x, y){

@EUDFunc
def Hypot(x, y):
    # (Line 263) if (x >= 0x80000000) x = -x;
    if EUDIf()(x >= 0x80000000):
        x << (-x)
        # (Line 264) if (y >= 0x80000000) y = -y;
    EUDEndIf()
    if EUDIf()(y >= 0x80000000):
        y << (-y)
        # (Line 265) var t = 0;
    EUDEndIf()
    t = _LVAR([0])
    # (Line 266) if(x < y){ t = x; x = y; y = t; } //Swap x, y so that y <= x
    if EUDIf()(x >= y, neg=True):
        t << (x)
        x << (y)
        y << (t)
        # (Line 267) var d = y + y - x;
    EUDEndIf()
    d = _LVAR([y + y - x])
    # (Line 268) if(d >= 0x80000000) d=0;
    if EUDIf()(d >= 0x80000000):
        d << (0)
        # (Line 269) d += y;
    EUDEndIf()
    d.__iadd__(y)
    # (Line 270) t = x + d / 5;
    t << (x + d // 5)
    # (Line 271) return t;
    EUDReturn(t)
    # (Line 272) }
    # (Line 274) function LocationDistance(loc1, loc2) {

@EUDFunc
def LocationDistance(loc1, loc2):
    # (Line 275) const a = loc_table+5*loc1;
    a = loc_table + 5 * loc1
    # (Line 276) const b = loc_table+5*loc2;
    b = loc_table + 5 * loc2
    # (Line 277) const x1 = maskread_epd(a, 0x1FFF) + maskread_epd(a+2, 0x1FFF);
    x1 = f_maskread_epd(a, 0x1FFF) + f_maskread_epd(a + 2, 0x1FFF)
    # (Line 278) const y1 = maskread_epd(a+1, 0x1FFF) + maskread_epd(a+3, 0x1FFF);
    y1 = f_maskread_epd(a + 1, 0x1FFF) + f_maskread_epd(a + 3, 0x1FFF)
    # (Line 279) const x2 = maskread_epd(b, 0x1FFF) + maskread_epd(b+2, 0x1FFF);
    x2 = f_maskread_epd(b, 0x1FFF) + f_maskread_epd(b + 2, 0x1FFF)
    # (Line 280) const y2 = maskread_epd(b+1, 0x1FFF) + maskread_epd(b+3, 0x1FFF);
    y2 = f_maskread_epd(b + 1, 0x1FFF) + f_maskread_epd(b + 3, 0x1FFF)
    # (Line 281) return Hypot(x1-x2, y1-y2);
    EUDReturn(Hypot(x1 - x2, y1 - y2))
    # (Line 282) }
    # (Line 284) function CheckNoneTargetSkillEPD(epd, Range, UnitLoc, TargetLoc, SkillOrder){

@EUDFunc
def CheckNoneTargetSkillEPD(epd, Range, UnitLoc, TargetLoc, SkillOrder):
    # (Line 286) if(MemoryXEPD(epd+0x4C/4, Exactly, SkillOrder, 0xFF00)){ //skillIndex2를 사용해야함.
    if EUDIf()(MemoryXEPD(epd + 0x4C // 4, Exactly, SkillOrder, 0xFF00)):
        # (Line 287) setloc_epd(TargetLoc, epd+0x58/4);
        f_setloc_epd(TargetLoc, epd + 0x58 // 4)
        # (Line 288) setloc_epd(UnitLoc, epd+0x28/4);
        f_setloc_epd(UnitLoc, epd + 0x28 // 4)
        # (Line 289) const skillRange = LocationDistance(UnitLoc,TargetLoc);
        skillRange = LocationDistance(UnitLoc, TargetLoc)
        # (Line 290) if(Range > skillRange){
        if EUDIf()(Range <= skillRange, neg=True):
            # (Line 291) MoveLocation(TargetLoc, 227, P12, TargetLoc);
            # (Line 292) SetMemoryXEPD(epd+0x4C/4, SetTo, 0x300, 0xFF00);
            DoActions(MoveLocation(TargetLoc, 227, P12, TargetLoc))
            # (Line 293) SetMemoryEPD(epd+0x10/4, SetTo, maskread_epd(epd+0x28/4, 0x1FFF1FFF));
            DoActions(SetMemoryXEPD(epd + 0x4C // 4, SetTo, 0x300, 0xFF00))
            # (Line 294) return true;
            DoActions(SetMemoryEPD(epd + 0x10 // 4, SetTo, f_maskread_epd(epd + 0x28 // 4, 0x1FFF1FFF)))
            EUDReturn(True)
            # (Line 295) }
            # (Line 296) }
        EUDEndIf()
        # (Line 297) return false;
    EUDEndIf()
    EUDReturn(False)
    # (Line 298) }
    # (Line 300) function CheckNoneTargetSkillEPDWithoutRange(epd, skill_idx){

@EUDFunc
def CheckNoneTargetSkillEPDWithoutRange(epd, skill_idx):
    # (Line 302) if(MemoryXEPD(epd+0x4C/4, Exactly, skill_idx, 0xFF00)){ //skillIndex2를 사용해야함.
    if EUDIf()(MemoryXEPD(epd + 0x4C // 4, Exactly, skill_idx, 0xFF00)):
        # (Line 303) SetMemoryXEPD(epd+0x4C/4, SetTo, 0x100, 0xFF00);
        # (Line 304) SetMemoryEPD(epd+0x10/4, SetTo, maskread_epd(epd+0x28/4, 0x1FFF1FFF));
        DoActions(SetMemoryXEPD(epd + 0x4C // 4, SetTo, 0x100, 0xFF00))
        # (Line 305) return true;
        DoActions(SetMemoryEPD(epd + 0x10 // 4, SetTo, f_maskread_epd(epd + 0x28 // 4, 0x1FFF1FFF)))
        EUDReturn(True)
        # (Line 306) }
        # (Line 307) return false;
    EUDEndIf()
    EUDReturn(False)
    # (Line 308) }
    # (Line 310) function AttackGround(

# (Line 311) attackLoc: TrgLocation,
# (Line 312) targetLoc: TrgLocation,
# (Line 313) attackUnit: TrgUnit,
# (Line 314) targetUnit: TrgUnit,
# (Line 315) player: TrgPlayer
# (Line 316) ) {
@EUDTypedFunc([TrgLocation, TrgLocation, TrgUnit, TrgUnit, TrgPlayer])
def AttackGround(attackLoc, targetLoc, attackUnit, targetUnit, player):
    # (Line 317) if (Memory(0x628438, Exactly, 0)) return;  // avoid EUDError when CCMU
    if EUDIf()(Memory(0x628438, Exactly, 0)):
        EUDReturn()
        # (Line 318) const aUnit = cunitepdread_epd(EPD(0x628438))[[1]];
    EUDEndIf()
    aUnit = f_cunitepdread_epd(EPD(0x628438))[1]
    # (Line 319) CreateUnit(1, attackUnit, attackLoc, player);
    # (Line 320) DoActions(aUnit.AddNumber(0x110 / 4));
    DoActions(CreateUnit(1, attackUnit, attackLoc, player))
    DoActions(aUnit.AddNumber(0x110 // 4))
    # (Line 321) SetMemoryEPD(aUnit, Add, 2);  // aUnit + 0x110 (CUnit::removeTimer)
    # (Line 323) if (Memory(0x628438, Exactly, 0)) return;  // avoid EUDError when CCMU
    DoActions(SetMemoryEPD(aUnit, Add, 2))
    if EUDIf()(Memory(0x628438, Exactly, 0)):
        EUDReturn()
        # (Line 324) const tunitptr, tunit = cunitepdread_epd(EPD(0x628438));
    EUDEndIf()
    tunitptr, tunit = List2Assignable([f_cunitepdread_epd(EPD(0x628438))])
    # (Line 325) CreateUnit(1, targetUnit, targetLoc, player);
    # (Line 326) DoActions(list(
    DoActions(CreateUnit(1, targetUnit, targetLoc, player))
    # (Line 327) tunit.AddNumber(0x110 / 4),
    # (Line 328) aUnit.AddNumber(-((0x110 - 0x5C) / 4))
    # (Line 329) ));
    DoActions(FlattenList([tunit.AddNumber(0x110 // 4), aUnit.AddNumber(-((0x110 - 0x5C) // 4))]))
    # (Line 330) SetMemoryEPD(aUnit, SetTo, tunitptr);  // aUnit + 0x5C (CUnit::targetUnit)
    # (Line 331) SetMemoryEPD(tunit, Add, 2);  // tunit + 0x110 (CUnit::removeTimer)
    DoActions(SetMemoryEPD(aUnit, SetTo, tunitptr))
    # (Line 333) DoActions(aUnit.AddNumber(-((0x5C - 0x4C) / 4)));
    DoActions(SetMemoryEPD(tunit, Add, 2))
    DoActions(aUnit.AddNumber(-((0x5C - 0x4C) // 4)))
    # (Line 334) SetMemoryXEPD(aUnit, SetTo, 0xA00, 0xFF00);  // order[10]=attack, 0x4D (CUnit::order)
    # (Line 335) }
    DoActions(SetMemoryXEPD(aUnit, SetTo, 0xA00, 0xFF00))
    # (Line 353) function ToggleUnitAvailability(player, unit){

@EUDFunc
def ToggleUnitAvailability(player, unit):
    # (Line 354) const dst = 0x57F27C + player*228 + unit;
    dst = 0x57F27C + player * 228 + unit
    # (Line 355) const q, r = div(dst - 0x58A364, 4);
    q, r = List2Assignable([f_div(dst - 0x58A364, 4)])
    # (Line 356) const v = bitlshift(1, 8 * r);
    v = f_bitlshift(1, 8 * r)
    # (Line 357) SetMemoryXEPD(q, Add, v, v);
    # (Line 358) }
    DoActions(SetMemoryXEPD(q, Add, v, v))
    # (Line 360) function SetUnitAvailability(player, unit, flag){

@EUDFunc
def SetUnitAvailability(player, unit, flag):
    # (Line 361) const dst = 0x57F27C + player*228 + unit;
    dst = 0x57F27C + player * 228 + unit
    # (Line 362) const q, r = div(dst - 0x58A364, 4);
    q, r = List2Assignable([f_div(dst - 0x58A364, 4)])
    # (Line 363) const v = bitlshift(1, 8 * r);
    v = f_bitlshift(1, 8 * r)
    # (Line 364) if (flag) SetMemoryXEPD(q, SetTo, v, v);
    if EUDIf()(flag):
        # (Line 365) else SetMemoryXEPD(q, SetTo, 0, v);
        DoActions(SetMemoryXEPD(q, SetTo, v, v))
    if EUDElse()():
        # (Line 366) }
        DoActions(SetMemoryXEPD(q, SetTo, 0, v))
    EUDEndIf()
    # (Line 368) function Shuffle(arr:EUDArray, length) {

@EUDTypedFunc([EUDArray, None])
def Shuffle(arr, length):
    # (Line 369) var temp;
    temp = EUDVariable()
    # (Line 370) var random;
    random = EUDVariable()
    # (Line 371) for(var i = 0; i < length-1; i++) {
    i = _LVAR([0])
    if EUDWhile()(i >= length - 1, neg=True):
        def _t2():
            i.__iadd__(1)
        # (Line 372) random = dwrand() % (length - i) + i;
        random << (f_dwrand() % (length - i) + i)
        # (Line 373) temp = arr[i];
        temp << (arr[i])
        # (Line 374) arr[i] = arr[random];
        _ARRW(arr, i) << (arr[random])
        # (Line 375) arr[random] = temp;
        _ARRW(arr, random) << (temp)
        # (Line 376) }
        # (Line 377) }
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
    # (Line 379) function GetLocationPos(location: TrgLocation){

@EUDTypedFunc([TrgLocation])
def GetLocationPos(location):
    # (Line 380) const loc = loc_table+5*location;
    loc = loc_table + 5 * location
    # (Line 381) return maskread_epd(loc, 0x1FFF), maskread_epd(loc+1, 0x1FFF), maskread_epd(loc+2, 0x1FFF), maskread_epd(loc+3, 0x1FFF);
    EUDReturn(f_maskread_epd(loc, 0x1FFF), f_maskread_epd(loc + 1, 0x1FFF), f_maskread_epd(loc + 2, 0x1FFF), f_maskread_epd(loc + 3, 0x1FFF))
    # (Line 382) }
    # (Line 384) function GetLocationCenterPos(location: TrgLocation) {

@EUDTypedFunc([TrgLocation])
def GetLocationCenterPos(location):
    # (Line 385) const loc = loc_table+5*location;
    loc = loc_table + 5 * location
    # (Line 386) return (maskread_epd(loc, 0x1FFF)+maskread_epd(loc+2, 0x1FFF))/2, (maskread_epd(loc+1, 0x1FFF)+maskread_epd(loc+3, 0x1FFF))/2;
    EUDReturn((f_maskread_epd(loc, 0x1FFF) + f_maskread_epd(loc + 2, 0x1FFF)) // 2, (f_maskread_epd(loc + 1, 0x1FFF) + f_maskread_epd(loc + 3, 0x1FFF)) // 2)
    # (Line 387) }
    # (Line 389) function CanNotScroll(){

@EUDFunc
def CanNotScroll():
    # (Line 390) if(IsUserCP()){
    if EUDIf()(IsUserCP()):
        # (Line 391) const offset = EPD(0x513B68);
        offset = EPD(0x513B68)
        # (Line 392) const actions = py_list();
        actions = list()
        # (Line 393) foreach(i : py_range(12)) {
        for i in range(12):
            # (Line 394) actions.append(SetMemoryEPD(offset + i, SetTo, 0));
            actions.append(SetMemoryEPD(offset + i, SetTo, 0))
            # (Line 395) }
            # (Line 396) actions.append(SetMemoryXEPD(offset + 12, SetTo, 0, 0xFF));

        actions.append(SetMemoryXEPD(offset + 12, SetTo, 0, 0xFF))
        # (Line 397) DoActions(actions);
        DoActions(actions)
        # (Line 398) }
        # (Line 399) }
    EUDEndIf()
    # (Line 401) function CanScroll(){

@EUDFunc
def CanScroll():
    # (Line 402) const scrollTable = [
    # (Line 403) 0x08080000, 0x00101010, 0x10080800, 0x08001810,
    # (Line 404) 0x18101008, 0x08080018, 0x20181810, 0x10100800,
    # (Line 405) 0x00282018, 0x20181008, 0x08003028, 0x38282018,
    # (Line 406) 0x40
    # (Line 407) ];
    scrollTable = _ARR(FlattenList([0x08080000, 0x00101010, 0x10080800, 0x08001810, 0x18101008, 0x08080018, 0x20181810, 0x10100800, 0x00282018, 0x20181008, 0x08003028, 0x38282018, 0x40]))
    # (Line 408) if(IsUserCP()){
    if EUDIf()(IsUserCP()):
        # (Line 409) const offset = EPD(0x513B68);
        offset = EPD(0x513B68)
        # (Line 410) const actions = py_list();
        actions = list()
        # (Line 411) foreach(i : py_range(12)) {
        for i in range(12):
            # (Line 412) actions.append(SetMemoryEPD(offset + i, SetTo, scrollTable[i]));
            actions.append(SetMemoryEPD(offset + i, SetTo, scrollTable[i]))
            # (Line 413) }
            # (Line 414) actions.append(SetMemoryXEPD(offset + 12, SetTo, scrollTable[12], 0xFF));

        actions.append(SetMemoryXEPD(offset + 12, SetTo, scrollTable[12], 0xFF))
        # (Line 415) DoActions(actions);
        DoActions(actions)
        # (Line 416) }
        # (Line 417) }
    EUDEndIf()
    # (Line 419) function NoRevealerVision()

# (Line 420) {
@EUDFunc
def NoRevealerVision():
    # (Line 421) static var timer = 0;
    timer = EUDVariable(0)
    # (Line 422) if (timer < 24*5) timer ++;
    if EUDIf()(timer >= 24 * 5, neg=True):
        timer.__iadd__(1)
        # (Line 423) else if(timer == 24*5){
    if EUDElseIf()(timer == 24 * 5):
        # (Line 424) timer ++;
        timer.__iadd__(1)
        # (Line 425) RemoveUnit(101, AllPlayers);
        # (Line 426) }
        DoActions(RemoveUnit(101, AllPlayers))
        # (Line 427) else{
    if EUDElse()():
        # (Line 428) SetDeaths(-111923, SetTo, 0, 0);
        # (Line 429) }
        DoActions(SetDeaths(-111923, SetTo, 0, 0))
        # (Line 430) }
    EUDEndIf()
    # (Line 432) function COrderPos(epd, order, pos)

# (Line 433) {
@EUDFunc
def COrderPos(epd, order, pos):
    # (Line 434) epd += 0x4D / 4;
    epd.__iadd__(0x4D // 4)
    # (Line 435) SetMemoryXEPD(epd, SetTo, order << 8, 0xFF00);
    # (Line 436) epd += (0x58 - 0x4C) / 4;
    DoActions(SetMemoryXEPD(epd, SetTo, _LSH(order,8), 0xFF00))
    epd.__iadd__((0x58 - 0x4C) // 4)
    # (Line 437) SetMemoryEPD(epd, SetTo, pos);
    # (Line 438) }
    DoActions(SetMemoryEPD(epd, SetTo, pos))
    # (Line 440) function CBringEPD(unitEPD, location: TrgLocation, dummyUnit: TrgUnit)

# (Line 441) {
@EUDTypedFunc([None, TrgLocation, TrgUnit])
def CBringEPD(unitEPD, location, dummyUnit):
    # (Line 442) MoveLocation(location, dummyUnit, AllPlayers, location);
    # (Line 443) const unitType = unitEPD + 0x64/4;
    DoActions(MoveLocation(location, dummyUnit, AllPlayers, location))
    unitType = unitEPD + 0x64 // 4
    # (Line 444) const originalUnitType = maskread_epd(unitType, 0xFF);
    originalUnitType = f_maskread_epd(unitType, 0xFF)
    # (Line 445) SetMemoryXEPD(unitType, SetTo, dummyUnit, 0xFFFF);
    # (Line 446) const ret = l2v(Bring(AllPlayers, AtLeast, 1, dummyUnit, location));
    DoActions(SetMemoryXEPD(unitType, SetTo, dummyUnit, 0xFFFF))
    ret = _L2V(Bring(AllPlayers, AtLeast, 1, dummyUnit, location))
    # (Line 447) SetMemoryXEPD(unitType, SetTo, originalUnitType, 0xFFFF);
    # (Line 448) return ret;
    DoActions(SetMemoryXEPD(unitType, SetTo, originalUnitType, 0xFFFF))
    EUDReturn(ret)
    # (Line 449) }
    # (Line 451) function BringEPD(unit_epd, location: TrgLocation){

@EUDTypedFunc([None, TrgLocation])
def BringEPD(unit_epd, location):
    # (Line 452) const posUnitX, posUnitY = posread_epd(unit_epd+0x28/4);
    posUnitX, posUnitY = List2Assignable([f_posread_epd(unit_epd + 0x28 // 4)])
    # (Line 453) const loc_epd = 5*location + loc_table;
    loc_epd = 5 * location + loc_table
    # (Line 454) if(
    _t1 = EUDIf()
    # (Line 455) MemoryEPD(loc_epd, AtMost, posUnitX) &&
    # (Line 456) MemoryEPD(loc_epd+2, AtLeast, posUnitX) &&
    # (Line 457) MemoryEPD(loc_epd+1, AtMost, posUnitY) &&
    # (Line 458) MemoryEPD(loc_epd+3, AtLeast, posUnitY)
    # (Line 459) ){
    if _t1(EUDSCAnd()(MemoryEPD(loc_epd, AtMost, posUnitX))(MemoryEPD(loc_epd + 2, AtLeast, posUnitX))(MemoryEPD(loc_epd + 1, AtMost, posUnitY))(MemoryEPD(loc_epd + 3, AtLeast, posUnitY))()):
        # (Line 460) return true;
        EUDReturn(True)
        # (Line 461) }
        # (Line 462) return false;
    EUDEndIf()
    EUDReturn(False)
    # (Line 463) }
    # (Line 465) function BringXY(pos_x, pos_y, location: TrgLocation){

@EUDTypedFunc([None, None, TrgLocation])
def BringXY(pos_x, pos_y, location):
    # (Line 466) const loc_epd = 5*location + loc_table;
    loc_epd = 5 * location + loc_table
    # (Line 467) if(
    _t1 = EUDIf()
    # (Line 468) MemoryEPD(loc_epd, AtMost, pos_x) &&
    # (Line 469) MemoryEPD(loc_epd+2, AtLeast, pos_x) &&
    # (Line 470) MemoryEPD(loc_epd+1, AtMost, pos_y) &&
    # (Line 471) MemoryEPD(loc_epd+3, AtLeast, pos_y)
    # (Line 472) ){
    if _t1(EUDSCAnd()(MemoryEPD(loc_epd, AtMost, pos_x))(MemoryEPD(loc_epd + 2, AtLeast, pos_x))(MemoryEPD(loc_epd + 1, AtMost, pos_y))(MemoryEPD(loc_epd + 3, AtLeast, pos_y))()):
        # (Line 473) return true;
        EUDReturn(True)
        # (Line 474) }
        # (Line 475) return false;
    EUDEndIf()
    EUDReturn(False)
    # (Line 476) }
    # (Line 478) function PolarLocation(loc: TrgLocation, length, angle) {

@EUDTypedFunc([TrgLocation, None, None])
def PolarLocation(loc, length, angle):
    # (Line 479) const x, y = lengthdir(length, angle);
    x, y = List2Assignable([f_lengthdir(length, angle)])
    # (Line 480) addloc(loc, x, y);
    f_addloc(loc, x, y)
    # (Line 481) }
    # (Line 484) function CGiveEPD(epd, new_owner:TrgPlayer) {

@EUDTypedFunc([None, TrgPlayer])
def CGiveEPD(epd, new_owner):
    # (Line 485) const player = epd + 0x4C / 4;
    player = epd + 0x4C // 4
    # (Line 486) if (MemoryXEPD(player, Exactly, 0, 0xFF00)) return;
    if EUDIf()(MemoryXEPD(player, Exactly, 0, 0xFF00)):
        EUDReturn()
        # (Line 487) const Owner = bread_epd(player, 0);
    EUDEndIf()
    Owner = f_bread_epd(player, 0)
    # (Line 488) const ptr = epd * 4 + 0x58A364;
    ptr = epd * 4 + 0x58A364
    # (Line 489) SetMemoryXEPD(player, SetTo, new_owner, 0xFF);
    # (Line 490) const prv, nxt = epd + 0x68 / 4, epd + 0x6C / 4;
    DoActions(SetMemoryXEPD(player, SetTo, new_owner, 0xFF))
    prv, nxt = List2Assignable([epd + 0x68 // 4, epd + 0x6C // 4])
    # (Line 491) const prev_ptr, prev_epd = cunitepdread_epd(prv);
    prev_ptr, prev_epd = List2Assignable([f_cunitepdread_epd(prv)])
    # (Line 492) const next_ptr, next_epd = cunitepdread_epd(nxt);
    next_ptr, next_epd = List2Assignable([f_cunitepdread_epd(nxt)])
    # (Line 493) if(prev_ptr >= 0x59CCA8) {
    if EUDIf()(prev_ptr >= 0x59CCA8):
        # (Line 494) dwwrite_epd(prev_epd + 0x6C / 4, next_ptr);
        f_dwwrite_epd(prev_epd + 0x6C // 4, next_ptr)
        # (Line 495) } else {
    if EUDElse()():
        # (Line 496) dwwrite_epd(EPD(0x6283F8) + Owner, next_ptr);
        f_dwwrite_epd(EPD(0x6283F8) + Owner, next_ptr)
        # (Line 497) }
        # (Line 498) if(next_ptr >= 0x59CCA8) {
    EUDEndIf()
    if EUDIf()(next_ptr >= 0x59CCA8):
        # (Line 499) dwwrite_epd(next_epd + 0x68 / 4, prev_ptr);
        f_dwwrite_epd(next_epd + 0x68 // 4, prev_ptr)
        # (Line 500) }
        # (Line 501) const NewHeader = EPD(0x6283F8) + new_owner;
    EUDEndIf()
    NewHeader = EPD(0x6283F8) + new_owner
    # (Line 502) if(MemoryEPD(NewHeader, AtLeast, 0x59CCA8)) {
    if EUDIf()(MemoryEPD(NewHeader, AtLeast, 0x59CCA8)):
        # (Line 503) const NewPrevPtr, NewPrevEPD = cunitepdread_epd(NewHeader);
        NewPrevPtr, NewPrevEPD = List2Assignable([f_cunitepdread_epd(NewHeader)])
        # (Line 504) const NewPrev_nxt = NewPrevEPD + 0x6C / 4;
        NewPrev_nxt = NewPrevEPD + 0x6C // 4
        # (Line 505) const NewNextPtr, NewNextEPD = cunitepdread_epd(NewPrev_nxt);
        NewNextPtr, NewNextEPD = List2Assignable([f_cunitepdread_epd(NewPrev_nxt)])
        # (Line 506) dwwrite_epd(NewPrev_nxt, ptr);
        f_dwwrite_epd(NewPrev_nxt, ptr)
        # (Line 507) dwwrite_epd(prv, NewPrevPtr);
        f_dwwrite_epd(prv, NewPrevPtr)
        # (Line 508) dwwrite_epd(nxt, NewNextPtr);
        f_dwwrite_epd(nxt, NewNextPtr)
        # (Line 509) if(NewNextPtr >= 0x59CCA8) {
        if EUDIf()(NewNextPtr >= 0x59CCA8):
            # (Line 510) dwwrite_epd(NewNextEPD + 0x68 / 4, ptr);
            f_dwwrite_epd(NewNextEPD + 0x68 // 4, ptr)
            # (Line 511) }
            # (Line 512) } else {
        EUDEndIf()
    if EUDElse()():
        # (Line 513) dwwrite_epd(NewHeader, ptr);
        f_dwwrite_epd(NewHeader, ptr)
        # (Line 514) dwwrite_epd(prv, 0);
        f_dwwrite_epd(prv, 0)
        # (Line 515) dwwrite_epd(nxt, 0);
        f_dwwrite_epd(nxt, 0)
        # (Line 516) }
        # (Line 517) }
    EUDEndIf()
    # (Line 520) function PlayerCounter() {

@EUDFunc
def PlayerCounter():
    # (Line 521) var count = 0;
    count = _LVAR([0])
    # (Line 522) foreach (cp : EUDLoopPlayer("Human")) {
    for cp in EUDLoopPlayer("Human"):
        # (Line 523) count ++;
        count.__iadd__(1)
        # (Line 524) }
        # (Line 525) return count;

    EUDReturn(count)
    # (Line 526) }
    # (Line 528) function GameDelayDetect(correct, text:TrgString) {

@EUDTypedFunc([None, TrgString])
def GameDelayDetect(correct, text):
    # (Line 529) const cp = getcurpl();
    cp = f_getcurpl()
    # (Line 530) setcurpl(getuserplayerid());
    f_setcurpl(f_getuserplayerid())
    # (Line 531) const _INV_SYS_TIME = EPD(0x51CE8C);
    _INV_SYS_TIME = EPD(0x51CE8C)
    # (Line 532) const _GAME_SPEED   = EPD(0x5124F0);
    _GAME_SPEED = EPD(0x5124F0)
    # (Line 533) static var frame = 0;
    frame = EUDVariable(0)
    # (Line 534) static var speed = 0;
    speed = EUDVariable(0)
    # (Line 535) static var std = 0;
    std = EUDVariable(0)
    # (Line 536) if(frame == 0) {
    if EUDIf()(frame == 0):
        # (Line 537) speed = maskread_epd(_GAME_SPEED, 0xFF);
        speed << (f_maskread_epd(_GAME_SPEED, 0xFF))
        # (Line 538) std = dwread_epd(_INV_SYS_TIME);
        std << (f_dwread_epd(_INV_SYS_TIME))
        # (Line 539) }
        # (Line 540) else if(speed){
    if EUDElseIf()(speed):
        # (Line 541) if(!MemoryEPD(_GAME_SPEED, Exactly, speed)) {
        if EUDIf()(MemoryEPD(_GAME_SPEED, Exactly, speed), neg=True):
            # (Line 543) frame = 0;
            frame << (0)
            # (Line 544) return;
            EUDReturn()
            # (Line 545) }
            # (Line 546) if(MemoryEPD(_INV_SYS_TIME, AtMost, std-1000)) {
        EUDEndIf()
        if EUDIf()(MemoryEPD(_INV_SYS_TIME, AtMost, std - 1000)):
            # (Line 547) const exp_frame = (42*24)/speed;
            exp_frame = (42 * 24) // speed
            # (Line 548) if(exp_frame/correct > frame) {
            if EUDIf()(exp_frame // correct <= frame, neg=True):
                # (Line 550) DisplayText(text);
                # (Line 551) }
                DoActions(DisplayText(text))
                # (Line 552) speed = 0;
            EUDEndIf()
            speed << (0)
            # (Line 553) }
            # (Line 554) }
        EUDEndIf()
        # (Line 555) frame ++;
    EUDEndIf()
    frame.__iadd__(1)
    # (Line 556) if(frame > 240) {
    if EUDIf()(frame <= 240, neg=True):
        # (Line 557) frame = 0;
        frame << (0)
        # (Line 558) }
        # (Line 559) setcurpl(cp);
    EUDEndIf()
    f_setcurpl(cp)
    # (Line 560) }
